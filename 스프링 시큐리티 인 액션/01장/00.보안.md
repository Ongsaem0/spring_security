<img width="867" height="224" alt="06" src="https://github.com/user-attachments/assets/ee7de6bb-b317-4f8f-999b-c61676da95b1" />[ 스프링 시큐리티 인 액션 ]


- 인증과 권한 부여의 취약성
    * 인증(Authentication) : 애플리케이션이 이를 이용하려는 사람을 식별하는 프로세스.
    * 권한부여(Authorization) : 인증된 호출자가 특정 기능과 데이터에 대한 이용권리가 있는지 확인하는 프로세스.
    * 인증 취약성 : 사용자가 악의를 가지고 다른 사람의 기능이나 데이터에 접근할 수 있다는 의미.

- 세션 고정이란?
    * 세션 고정(Session fixation) 취약성은 웹 애플리케이션의 더 구체적이고 심각한 약점.
    * 이 취약성이 존재하면 공격자는 이미 생성된 세션 ID를 재이용해 유요한 사용자를 가장할 수 있음.
    * 인증 프로세스 중에 고유한 세션 ID를 할당하지 않아 기존 세션 ID가 재사용될 가능성이 있을때 발생.

- XXS(교차 사이트 스크립팅)란?
    * 서버에 노출된 웹 서비스로 클라이언트 쪽 스크립트를 주입해 다른 사용자가 이를 실행하도록 하는 공격.


- CSRF(사이트 간 요청 위조)란?
    * CSRF 공격은 사용자가 로그인된 웹사이트에서 자신의 의지와 상관없이 악의적인 요청을 보내도록 유도하는 웹 보안 취약점 공격이다.
￼<img width="800" height="348" alt="01" src="https://github.com/user-attachments/assets/68cce155-c922-40a9-b8ae-09b13e2192d0" />


- 공개 정보가 아닌 것은 절대 로그에 기록하지 말아야한다.
- 권한은 컨트롤러 계층에만 권한을 주지말고 서비스나 애플리케이션 모든 계층에 권한 부여를 적용해야함.
 


{ 일체형 웹 애플리케이션 설계 }
- 일반적으로 애플리케이션이 HTTP 요청을 수신하고 HTTP 응답을 클라이언트에 보내는 일반 서블릿 흐름을 가지는데 세션이 있는 한 세션 고정 취약성과 CSRF 가능성을 고려해야한다.

- CSRF 방지 토큰 : 스프링 시큐리티에 기본적으로 들어가있음. CSRF 보호와 원점 CORS의 검증도 기본적으로 활성화되어 있다. 
    * 인증과 권한 부여를 위해 스프링 시큐리티에서 암시적 로그인 양식 구성을 이용하도록 선택할 수 있음.
        * 로그인, 로그아웃 모양과 느낌만 재정의하면 되고 인증과 권한 부여 구성의 기본 통합이라는 이점을 얻을 수 있음. -> 세션 고정 취약성 완화되는 이점도 있음.

- 서버 쪽 세션을 줄이고 클라이언트 쪽 세션으로 대체하는 것이 좋음.

- 사용자가 모든 요청에 대해 자격증명을 입력해야 하는 것은 x, 클라이언트쪽에 저장도 x. 이 방법은 권장하지 않는다.





{ OAuth2 흐름 이해 }
- OAuth2 프레임워크는 권한 부여 서버와 리서스 서버라는 두 가지 별도의 엔티티를 정의한다. 권한 부여 서버의 목적은 사용자에게 권한을 부여하고 사용자의 이용 권리 집합을 지정하는 토큰을 제공하는 것이다. 이 기능을 구현하는 백엔드 부분을 “ 리소스 서버 “ 라고 하며, 호출할 수 있는 엔드 포인트는 “ 보호된 리소스 “ 로 볼 수 있다. 

- OAuth2의 일반적인 흐름
    * 1. 사용자가 애플리케이션(클라이언트)의 기능에 접근한다. 애플리케이션은 백엔드의 리소스를 호출해야 한다.

    * 2. 애플리케이션이 리소스를 호출하려면 먼저 액세스 토큰을 얻어야 하므로 권한 부여 서버를 호출해서 토큰을 얻는다. 이 요청을 위해 사용자 자격 증명이나 때에 따라 갱신 토큰을 보낸다.

    * 3. 자격 증명이나 갱신 토큰이 올바르면 권한 부여 서버가 새로운 액세스 토큰을 클라이언트로 반환한다.

    * 4. 필요한 리소스를 호출할 때 리소스 서버에 대한 요청의 헤더는 액세스 토큰을 이용한다.
￼<img width="731" height="326" alt="02" src="https://github.com/user-attachments/assets/5c6bf45f-b086-47e2-8251-2de4593af45f" />




* 토큰의 수명은 고정이고 오래 유지되지 않음. 만료되면 앱이 새 토큰을 받아야한다. 서버는 필요한 경우 토큰의 만료 시간보다 일찍 실격시킬 수 있음. 다음 목록은 이 흐름의 몇가지 이점을 나열한 것.

    * 클라이언트는 사용자 자격 증명을 저장할 필요 없이 액세스 토큰과(최종적으로 ) 갱신 토큰만 저장하면 됨.

    * 애플리케이션은 사용자 자격 증명을 (종종 네트워크에서) 노출하지 않는다.

    * 누군가 토큰을 가로채면 사용자 자격 증명을 무효로 할 필요 없이 토큰 실격 가능.

    * 토큰 이용하면 제 3자가 사용자를 가장하지 않고도 사용자 대신 리소스 접근 가능. 
        * 공격자가 토큰 가로채기 가능하지만 수명 제한으로 악용할 수 있는 기간도 제한함.



* 토큰 관리 좋은 방법
    * 앱의 메모리에 토큰 유지.

    * 데이터베이스에 토큰 유지.

    * JWR(JSON 웹 토큰)를 통한 암호화 서명 사용.



{ API 키, 암호화 서명, IP 검증을 이용해 요청 보안 }

- 정적 키 이용은 약한 접근법 -> IP 주소 허용 목록 하고, 데이터 센터 외부로 트래픽이 이동하면 가로채기 쉬움.

- 암호화 서명 이용. 
    * 자신의 키를 이용하고, 비대칭 키 쌍으로 이용해서 개인 키 교환 X
    * 더 간단한건 처음에 교환이 필요한 대칭 키를 이용하며 이때는 서명을 계산하는 데 더 많은 리소스가 소비된다는 단점 있음.
￼<img width="834" height="410" alt="03" src="https://github.com/user-attachments/assets/c6ecb1ed-7f56-441c-a2da-d9474f3e5058" />

    * 하지만 대부분의 경우 IP 검증은 애플리케이션 수준에서 수행되지 않고 훨씬 이전의 네트워킹 계층에서 수행된다.




- 스프링 시큐리티 아키텍처의 주 구성 요소와 이들 간의 관계.
￼<img width="884" height="577" alt="04" src="https://github.com/user-attachments/assets/0f2463f3-806a-4a6d-9090-11a274b12def" />

    * 인증 필터는 인증 요청을 인증 관리자에 위임하고 응답을 바탕으로 보안 컨텍스트를 구성한다.
    * 인증 관리자는 인증 공급자를 이용해 인증을 처리한다.
    * 인증 공급자는 인증 논리를 구현한다.
    * 인증 공급자는 사용자 관리 책임을 구현하는 사용자 세부 정보 서비스를 인증 논리에 이용한다.
    * 인증 공급자는 암호 관리를 구현하는 암호 인코더를 인증 논리에 이용한다.
    * 보안 컨텍스트는 인증 프로세스 후 인증 데이터를 유지한다.



{ 자동으로 구성되는 빈 }

* UserDetailsService : 
    * 사용자에 관한 세부 정보는 스프링 시큐리티로 UserDetailsService 계약을 구현하는 객체가 관리.
        * UserDetailsService는 “인터페이스”를 말함.
        * 구현하는 객체는 Class를 말한다.
        * 관리는 “일을 맡긴다는 의미”.
    * “사용자 정보를 가져오는 방법은, 스프링 시큐리티가 정해준 규칙(계약)대로 만든 클래스(객체)가 담당한다.”

* PasswordEncoder : 
    * 암호를 인코딩함.
    * 암호가 기존 인코딩과 일치하는지 확인함.


* Basic 인증에서는 클라이언트가 사용자 이름과 암호를 HTTP Authorization 헤더를 통해 보내기만 하면 된다.
￼<img width="809" height="132" alt="05" src="https://github.com/user-attachments/assets/fb9ee575-8b00-4da1-80fe-d7af833c1a64" />




* 스프링 시큐리티의 다른 부분을 다양한 스타일로 혼합하는 경우도 있지만 바람직하지 않음. -> 유연성을 남용해선 X



* 구성 요소를 재정의 하는 방법을 보여주기위해 스프링 시큐리티에 있는 InMemoryUserDetailsManager라는 구현을 이용할 것이다.

* UserDetailsService보다 복잡하지만 다를 바 없이 이용할 수 있음. -> 예제나 개념 증명용으로 좋은 툴임.
<img width="867" height="224" alt="06" src="https://github.com/user-attachments/assets/ab533b83-ead9-49c5-a82f-a3059c2da560" />
![Uploading 07.png…]()


￼
* var를 쓰면 알아서 타입이 맞춰짐(이름 긴 클래스들 치기 귀찮고, 코드가 지저분해보임).

* 인스턴스를 만들때는 사용자와 암호 그리고 하나 이상의 권한을 지정히야 함.
    * 권한(authoriy)은 해당 사용자에게 허용된 작업이며 아무 문자열이나 지정하면됨.
<img width="784" height="145" alt="08" src="https://github.com/user-attachments/assets/4eef68b8-bad9-4a2c-b6b8-cccdc8b5ccab" />
ㅍ<img width="778" height="365" alt="09" src="https://github.com/user-attachments/assets/7f239c25-d5fe-4a76-aa90-f7e4ba6f643b" />


￼
* UserDetailsService를 재정의 해서 PasswordEncoder도 다시 선언해야됨.

* 지금 실행하면 엔드포인트를 호출할때 예외 발생함 -> 인증하려고하면 스프링 시큐리티가 암호를 관리하는 방법을 모른다고 인식해서.
    * PasswordEncoder 빈을 컨텍스트에 추가해서 구현하면 됨.
<img width="781" height="119" alt="10" src="https://github.com/user-attachments/assets/8562f27c-2fbb-4cdc-9266-19f8bac05e02" />


* 사용자 이름이 john이고 암호가 12345인 새 사용자로 엔드포인트를 호출하면? 아래처럼 콘솔에 나옴.
<img width="782" height="59" alt="11" src="https://github.com/user-attachments/assets/7008dce8-ee2a-4cfe-b702-c7c7cbc27e36" />





{ 엔드포인트 권한 부여 구성 재정의 }
- HTTP Basic 인증은 대부분의 애플리케이션 아키텍쳐에 적합 X
-  BUT 모든 엔드포인트를 보호할 필요 X. 보안이 필요한 엔드포인트에 다른 권한 부여 규칙을 선택 해야 할 수 도 있음
- 이러한 변경을 위해 WebSecurityConfigurerAdapter 클래스 확장하자!
    * configure(HttpSecurity http) 메서드 재정의할 수 있음.
￼<img width="782" height="334" alt="12" src="https://github.com/user-attachments/assets/96480e2a-fae8-47e8-845b-5d66d13d8ee7" />

    * authenticated(); 대신 permitAll(); 을 쓰면 인증 없이 엔드포인트 호출 가능! -> 자격증명 필요 없음.






- 동일한 구성을 수행하는 다른 방법
* UserDetailsService와 PasswordEncoder 두 객체를 빈으로 정의하는 대신 configure(AuthenticationManagerbuilder auth) 메소드로 설정가능.
    * 이 메서드 형식의 매개변수로 UserDetailsService, PasswordEncoder 설정가능.
￼
<img width="779" height="768" alt="13" src="https://github.com/user-attachments/assets/803723a5-e81f-42ff-b51f-c14a46e4c17d" />
* 이전꺼와의 차이점 : 메서드 안에서 로컬로 작업 수행된다는 점.


* In-memory 방식은 권장 X -> 사용자를 DB에 저장하거나 다른 시스템에서 가져와야되서 길고 복잡해질 가능성 농후함.





{ AuthenticationProvider 구현 재정의 }

* 구성 요소에 작업을 위임하는 AuthenticationProvider도 맞춤 구성할 수 있음.
￼<img width="812" height="541" alt="14" src="https://github.com/user-attachments/assets/fc53c12b-d7a3-417a-b3c7-bb01035360e3" />


* 인증 논리를 구현하고 사용자 관리와 암호 관리를 각각 UserDetailsService 및 PasswordEncoder에 위임함.

* 스프링 시큐리티 아키텍처에 반영된 책임은 유지하는게 좋음. 세분화된 책임과 느슨하게 결합되어있어서.

* 시큐리티가 유연하고 애플리케이션에 통합 하기 쉬운 이유가 이 설계 덕분.
    * BUT 이거 믿고 설계 막 바꾸면 복잡해지니까 조심.
￼<img width="781" height="687" alt="15" src="https://github.com/user-attachments/assets/52251cc5-5f3c-4966-b00a-ede650d135d6" />

* If-else 절의 조건으로 UserDetailsService 및 PasswordEncoder의 책임을 대체함.
    * 두 개의 빈을 이용해야하는건 아니지만, 인증을 위해 사용자와 암호를 관리 -> 논리를 분리하는 것이 좋음.



￼<img width="778" height="502" alt="16" src="https://github.com/user-attachments/assets/1ecb4bf8-e727-49ee-b414-6d203a2f80cc" />

* Config로 인증 논리에 정의된 유일하게 인식된 사용자 존과 암호 12345를 이용해 엔트포인트 호출 가능!






{ 프로젝트에 여러 구성 클래스 이용 }

* 구성 클래스도 책임을 분리하는 것이 좋음. -> 구성이 복잡해지기 때문.
    * 항상 한 클래스가 하나의 책임을 맡도록 하는것이 바람직.
















